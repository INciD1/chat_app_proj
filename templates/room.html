{% extends 'base.html' %} {% block content %}
<div class="message-box">
  <div class="room-header">
    <h2><i class="fas fa-comments"></i> ‡∏´‡πâ‡∏≠‡∏á‡πÅ‡∏ä‡∏ó <span class="room-code">{{code}}</span></h2>
  </div>
  <div class="messages" id="messages"></div>
  <div class="inputs">
    <div class="message-tools">
      <button type="button" id="emoji-btn" class="tool-btn"><i class="far fa-smile"></i></button>
      <button type="button" id="gif-btn" class="tool-btn"><i class="fas fa-image"></i></button>
      <div id="emoji-picker" class="emoji-picker">
        <!-- Emoji ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏î‡πâ‡∏ß‡∏¢ JavaScript -->
      </div>
      <div id="gif-picker" class="gif-picker">
        <div class="gif-search">
          <input type="text" id="gif-search" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ GIF...">
        </div>
        <div id="gif-results" class="gif-results">
          <!-- ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå GIF ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà -->
        </div>
      </div>
    </div>
    <input
      type="text"
      placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà..."
      name="message"
      id="message"
      autocomplete="off"
    />
    <button type="button" id="send-btn" onclick="sendMessage()">
      <i class="fas fa-paper-plane"></i>
    </button>
  </div>
</div>

<script type="text/javascript">
  var socketio = io({
    transports: ['polling', 'websocket']
  });

  const messages = document.getElementById("messages");
  const currentUser = "{{ session.get('name') }}";
  const GIPHY_API_KEY = "sJghslgtT6djr7bYTPtF4jiz2PwhdYsm";

  // Common emojis array
  const commonEmojis = [
  // ‡∏´‡∏°‡∏ß‡∏î‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏•‡∏∞‡∏≠‡∏≤‡∏£‡∏°‡∏ì‡πå‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
  "üòÄ", "üòÅ", "üòÇ", "ü§£", "üòÉ", "üòÑ", "üòÖ", "üòÜ", "üòâ", "üòä", 
  "üòã", "üòé", "üòç", "üòò", "ü•∞", "üòó", "üòô", "üòö", "üôÇ", "ü§ó",
  "ü§©", "ü§î", "ü§®", "üòê", "üòë", "üò∂", "üôÑ", "üòè", "üò£", "üò•",
  "üòÆ", "ü§ê", "üòØ", "üò™", "üò´", "üò¥", "üòå", "üòõ", "üòú", "üòù",
  "ü§§", "üòí", "üòì", "üòî", "üòï", "üôÉ", "ü§ë", "üò≤", "‚òπÔ∏è", "üôÅ",
  "üòñ", "üòû", "üòü", "üò§", "üò¢", "üò≠", "üò¶", "üòß", "üò®", "üò©",
  "ü§Ø", "üò¨", "üò∞", "üò±", "ü•µ", "ü•∂", "üò≥", "ü§™", "üòµ", "üò°",
  "üò†", "ü§¨", "üò∑", "ü§í", "ü§ï", "ü§¢", "ü§Æ", "ü§ß", "üòá", "ü•≥",
  "ü•¥", "ü•∫", "ü§†", "ü§°", "ü§•", "ü§´", "ü§≠", "üßê", "ü§ì", "üòà",
  "üëã", "üëå", "üëç", "üëé", "‚ù§Ô∏è", "üî•", "‚ú®", "üéâ", "üëè", "üôè",
  
  // ‡∏´‡∏°‡∏ß‡∏î‡πÉ‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
  "üò∫", "üò∏", "üòπ", "üòª", "üòº", "üòΩ", "üôÄ", "üòø", "üòæ", "üëª",
  "üëΩ", "üëæ", "ü§ñ", "üí©", "üíÄ", "üëπ", "üë∫", "ü§†", "ü§í", "ü§ï",
  "ü§¢", "ü§ß", "ü•¥", "ü•µ", "ü•∂", "ü•≥", "ü§Ø", "üß†", "üëÅÔ∏è", "üëÄ",
  
  // ‡∏´‡∏°‡∏ß‡∏î‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á‡∏°‡∏∑‡∏≠‡πÅ‡∏•‡∏∞‡∏£‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏¢
  "üëç", "üëé", "üëä", "‚úä", "ü§õ", "ü§ú", "ü§û", "‚úåÔ∏è", "ü§ü", "ü§ò",
  "üëà", "üëâ", "üëÜ", "üëá", "‚òùÔ∏è", "üëã", "ü§ö", "üñêÔ∏è", "‚úã", "üññ",
  "üëå", "ü§è", "‚úçÔ∏è", "üôè", "ü§ù", "üí™", "ü¶æ", "ü¶ø", "ü¶µ", "ü¶∂",
  "üëÇ", "ü¶ª", "üëÉ", "üë∂", "üßí", "üë¶", "üëß", "üßë", "üë®", "üë©",
  
  // ‡∏´‡∏°‡∏ß‡∏î‡∏™‡∏±‡∏ï‡∏ß‡πå
  "üê∂", "üê±", "üê≠", "üêπ", "üê∞", "ü¶ä", "üêª", "üêº", "üê®", "üêØ",
  "ü¶Å", "üêÆ", "üê∑", "üê∏", "üêµ", "üôà", "üôâ", "üôä", "üêî", "üêß",
  "üê¶", "üê§", "ü¶Ü", "ü¶Ö", "ü¶â", "ü¶á", "üê∫", "üêó", "üê¥", "ü¶Ñ",
  "üêù", "üêõ", "ü¶ã", "üêå", "üêû", "üêú", "ü¶ü", "ü¶ó", "üï∑Ô∏è", "ü¶Ç",
  
  // ‡∏´‡∏°‡∏ß‡∏î‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÅ‡∏•‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏î‡∏∑‡πà‡∏°
  "üçé", "üçê", "üçä", "üçã", "üçå", "üçâ", "üçá", "üçì", "üçà", "üçí",
  "üçë", "ü•≠", "üçç", "ü••", "ü•ù", "üçÖ", "üçÜ", "ü•ë", "ü•¶", "ü•¨",
  "üå≠", "üçî", "üçü", "üçï", "ü•™", "ü•ô", "üßÜ", "üåÆ", "üåØ", "ü•ó",
  "ü•ò", "ü•´", "üçù", "üçú", "üç≤", "üçõ", "üç£", "üç±", "ü•ü", "ü¶™",
  "üç¶", "üçß", "üç®", "üç©", "üç™", "üéÇ", "üç∞", "üßÅ", "ü•ß", "üç´",
  "‚òï", "üçµ", "üßÉ", "ü•§", "üßã", "üç∂", "üç∫", "üçª", "ü•Ç", "üç∑",
  
  // ‡∏´‡∏°‡∏ß‡∏î‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÅ‡∏•‡∏∞‡∏Å‡∏µ‡∏¨‡∏≤
  "‚öΩ", "üèÄ", "üèà", "‚öæ", "ü•é", "üéæ", "üèê", "üèâ", "ü•è", "üé±",
  "üèì", "üè∏", "üèí", "üèë", "ü•ç", "üèè", "ü•Ö", "‚õ≥", "ü™Ä", "üéØ",
  "üéÆ", "üé≤", "üß©", "üé≠", "üé®", "üé¨", "üé§", "üéß", "üéº", "üéπ",
  
  // ‡∏´‡∏°‡∏ß‡∏î‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÅ‡∏•‡∏∞‡∏™‡∏¥‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÜ
  "üíå", "üíò", "üíù", "üíñ", "üíó", "üíì", "üíû", "üíï", "‚ù§Ô∏è", "üß°",
  "üíõ", "üíö", "üíô", "üíú", "ü§é", "üñ§", "ü§ç", "üíØ", "üí¢", "üí•",
  "üí´", "üí¶", "üí®", "üï≥Ô∏è", "üí£", "üí¨", "üëÅÔ∏è‚Äçüó®Ô∏è", "üó®Ô∏è", "üóØÔ∏è", "üí≠",
  "üí§", "üëã", "üéÉ", "üéÑ", "üéÜ", "üéá", "üß®", "‚ú®", "üéà", "üéâ",
  "üéä", "üéã", "üéç", "üéé", "üéè", "üéê", "üéë", "üßß", "üéÄ", "üéÅ",
  "üéóÔ∏è", "üéüÔ∏è", "üé´", "üéñÔ∏è", "üèÜ", "üèÖ", "ü•á", "ü•à", "ü•â", "‚ö°",
  "‚òÄÔ∏è", "üåù", "üåû", "‚≠ê", "üåü", "üå†", "üåà", "‚òÅÔ∏è", "‚õÖ", "‚õàÔ∏è"
  ];

  // Populate emoji picker
  const populateEmojiPicker = () => {
    const emojiPicker = document.getElementById("emoji-picker");
    emojiPicker.innerHTML = ""; // Clear existing emojis
    
    commonEmojis.forEach(emoji => {
      const emojiSpan = document.createElement("span");
      emojiSpan.textContent = emoji;
      emojiSpan.className = "emoji";
      emojiSpan.addEventListener("click", () => {
        const messageInput = document.getElementById("message");
        messageInput.value += emoji;
        messageInput.focus();
        toggleEmojiPicker(false);
      });
      
      emojiPicker.appendChild(emojiSpan);
    });
  };

  // Toggle emoji picker
  const toggleEmojiPicker = (show = undefined) => {
    const emojiPicker = document.getElementById("emoji-picker");
    const gifPicker = document.getElementById("gif-picker");
    
    if (show === undefined) {
      emojiPicker.classList.toggle("show");
    } else {
      emojiPicker.classList.toggle("show", show);
    }
    
    // Always hide GIF picker when toggling emoji picker
    gifPicker.classList.remove("show");
  };

  // Toggle GIF picker
  const toggleGifPicker = (show = undefined) => {
    const gifPicker = document.getElementById("gif-picker");
    const emojiPicker = document.getElementById("emoji-picker");
    
    if (show === undefined) {
      gifPicker.classList.toggle("show");
    } else {
      gifPicker.classList.toggle("show", show);
    }
    
    // Always hide emoji picker when toggling GIF picker
    emojiPicker.classList.remove("show");
    
    // Focus on search input when showing GIF picker
    if (gifPicker.classList.contains("show")) {
      document.getElementById("gif-search").focus();
    }
  };

  window.GIPHY_API_KEY = "sJghslgtT6djr7bYTPtF4jiz2PwhdYsm";; 
// Search for GIFs
  const searchGifs = (query) => {
    const resultsDiv = document.getElementById("gif-results");
    resultsDiv.innerHTML = '<div class="gif-loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤...</div>';
  
    fetch(`https://api.giphy.com/v1/gifs/search?api_key=${window.GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=15&rating=g`)
      .then(response => response.json())
        .then(data => {
          resultsDiv.innerHTML = '';
        
          if (data.data.length === 0) {
            resultsDiv.innerHTML = '<div class="gif-no-results">‡πÑ‡∏°‡πà‡∏û‡∏ö GIF ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</div>';
            return;
          }
        
        data.data.forEach(gif => {
          const gifItem = document.createElement("div");
          gifItem.className = "gif-item";
          
          const img = document.createElement("img");
          img.src = gif.images.fixed_height_small.url;
          img.alt = gif.title;
          
          img.addEventListener("click", () => {
            sendGif(gif.images.fixed_height.url, gif.title);
            toggleGifPicker(false);
          });
          
          gifItem.appendChild(img);
          resultsDiv.appendChild(gifItem);
        });
      })
      .catch(error => {
        console.error("Error fetching GIFs:", error);
        resultsDiv.innerHTML = '<div class="gif-error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ GIF</div>';
      });
  };

  // Send GIF message
  const sendGif = (url, title) => {
    socketio.emit("message", { 
      data: `[gif:${url}]`, 
      isGif: true, 
      gifTitle: title 
    });
  };

  const createMessage = (name, msg, isSystem = false, isGif = false, gifTitle = "") => {
    if (isSystem) {
      const content = `
      <div class="system-message">
        <span>${name} ${msg}</span>
      </div>
      `;
      messages.innerHTML += content;
    } else if (isGif) {
      // Extract the GIF URL from message format [gif:URL]
      const gifUrl = msg.substring(5, msg.length - 1);
      const isCurrentUser = name === currentUser;
      const content = `
      <div class="text ${isCurrentUser ? 'sent' : ''}">
        <div class="message-content">
          <strong>${isCurrentUser ? '‡∏Ñ‡∏∏‡∏ì' : name}:</strong> 
          <div class="gif-container">
            <img src="${gifUrl}" alt="${gifTitle}" class="gif-message" />
          </div>
        </div>
        <span class="muted">
          ${new Date().toLocaleString()}
        </span>
      </div>
      `;
      messages.innerHTML += content;
    } else {
      // Process message to render emojis (not necessary, modern browsers render emojis automatically)
      const isCurrentUser = name === currentUser;
      const content = `
      <div class="text ${isCurrentUser ? 'sent' : ''}">
        <div class="message-content">
          <strong>${isCurrentUser ? '‡∏Ñ‡∏∏‡∏ì' : name}:</strong> ${msg}
        </div>
        <span class="muted">
          ${new Date().toLocaleString()}
        </span>
      </div>
      `;
      messages.innerHTML += content;
    }
    
    // Auto scroll to bottom
    messages.scrollTop = messages.scrollHeight;
  };

  socketio.on("message", (data) => {
    // Check if this is a system message (has entered/left the room)
    const isSystemMessage = data.message === "has entered the room" || data.message === "has left the room";
    
    // Check if this is a GIF message
    const isGif = data.message && data.message.startsWith("[gif:") && data.message.endsWith("]");
    
    createMessage(data.name, data.message, isSystemMessage, isGif, data.gifTitle);
  });

  const sendMessage = () => {
    const message = document.getElementById("message");
    if (message.value == "") return;
    socketio.emit("message", { data: message.value });
    message.value = "";
  };
  
  // Event listeners
  document.addEventListener("DOMContentLoaded", function() {
    // Populate emoji picker
    populateEmojiPicker();
    
    // Emoji button click
    document.getElementById("emoji-btn").addEventListener("click", () => {
      toggleEmojiPicker();
    });
    
    // GIF button click
    document.getElementById("gif-btn").addEventListener("click", () => {
      toggleGifPicker();
    });
    
    // GIF search input
    document.getElementById("gif-search").addEventListener("keyup", function(event) {
      if (event.key === "Enter" && this.value.trim() !== "") {
        searchGifs(this.value.trim());
      }
    });
    
    // Close pickers when clicking outside
    document.addEventListener("click", function(event) {
      if (!event.target.closest("#emoji-picker") && !event.target.closest("#emoji-btn") &&
          !event.target.closest("#gif-picker") && !event.target.closest("#gif-btn")) {
        document.getElementById("emoji-picker").classList.remove("show");
        document.getElementById("gif-picker").classList.remove("show");
      }
    });
    
    // Add event listener for Enter key in message input
    document.getElementById("message").addEventListener("keypress", function(event) {
      if (event.key === "Enter") {
        sendMessage();
      }
    });

    // Focus on message input when page loads
    document.getElementById("message").focus();
  });
</script>

{% for msg in messages %}
<script type="text/javascript">
  // Check if this is a system message
  const isSystemMsg = "{{msg.message}}" === "has entered the room" || "{{msg.message}}" === "has left the room";
  
  // Check if this is a GIF message
  const isGifMsg = "{{msg.message}}".startsWith("[gif:") && "{{msg.message}}".endsWith("]");
  
  const msgName = "{{msg.name}}";
  const msgContent = "{{msg.message}}";
  const gifTitle = "{{msg.gifTitle|default('')}}";
  
  createMessage(msgName, msgContent, isSystemMsg, isGifMsg, gifTitle);
</script>
{% endfor %}
{% endblock %}